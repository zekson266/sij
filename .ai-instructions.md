# AI Assistant Instructions for This Project

## üî¥ CRITICAL: Always Verify Builds After Code Changes

### When Making Frontend Changes:

1. **ALWAYS check build status** before considering the task complete:
   ```bash
   cd frontend && npm run build
   ```
   - If build fails, FIX IT IMMEDIATELY
   - Never proceed if TypeScript compilation errors exist
   - Report build failures to the user immediately

2. **Verify the code is in the bundle** (for critical features):
   ```bash
   # After successful build, verify code exists
   grep -r "functionName" frontend/dist/assets/*.js
   # Or check bundle size changed
   ls -lh frontend/dist/assets/*.js
   ```

3. **After Docker builds**, always check logs:
   ```bash
   docker compose logs frontend-build | tail -50
   ```
   - Look for "error" or "ERROR" in output
   - Verify exit code is 0

### When Making Backend Changes:

1. **Check Python syntax/imports**:
   ```bash
   cd backend && python -m py_compile app/**/*.py
   ```

2. **Verify Docker build succeeds**:
   ```bash
   docker compose build backend
   docker compose logs backend | grep -i error
   ```

### Build Verification Checklist (Run After Any Code Change):

- [ ] TypeScript compiles without errors (`npm run build` in frontend/)
- [ ] Build output exists (`frontend/dist/` directory has files)
- [ ] JavaScript bundle was created (check `frontend/dist/assets/*.js`)
- [ ] Docker build completes successfully
- [ ] No errors in Docker logs
- [ ] Services start successfully

### Common Build Failure Patterns to Watch For:

1. **TypeScript errors:**
   - `error TS2339: Property 'X' does not exist on type 'Y'`
   - Fix: Add proper types or use type assertions `(obj as any)`

2. **Import errors:**
   - `Cannot find module 'X'`
   - Fix: Check import paths, verify file exists

3. **Syntax errors:**
   - Missing brackets, semicolons, etc.
   - Fix: Check code syntax

### If Build Fails:

1. **STOP** - Do not proceed with deployment
2. **Report the error** to the user immediately
3. **Show the full error message** from build logs
4. **Fix the issue** before continuing
5. **Re-verify** the build succeeds

### Quick Build Check Commands:

```bash
# Frontend build check
cd frontend && npm run build && echo "‚úÖ Build successful" || echo "‚ùå Build failed"

# Check if latest code is in bundle (example: subdomain detection)
grep -q "isTenantSubdomain\|getSubdomain" frontend/dist/assets/*.js && echo "‚úÖ Code found" || echo "‚ùå Code missing"

# Docker build check
docker compose build frontend-build 2>&1 | grep -i error && echo "‚ùå Build errors found" || echo "‚úÖ Build successful"
```

### When User Reports "Code Not Working":

1. **First check**: Did the build succeed?
   ```bash
   docker compose logs frontend-build --tail 50
   ```

2. **Second check**: Is the code in the bundle?
   ```bash
   # Search for key function/string in built bundle
   strings frontend/dist/assets/*.js | grep "keyFunctionName"
   ```

3. **Third check**: Is the new bundle being served?
   ```bash
   # Check what JS file is referenced in index.html
   grep "index-.*\.js" frontend/dist/index.html
   # Check if that file exists
   ls -la frontend/dist/assets/ | grep "index-.*\.js"
   ```

### Best Practices:

- **Always run build verification** after making code changes
- **Never assume** the build succeeded - always verify
- **Check Docker logs** after `docker compose build` or `docker compose up`
- **Verify bundle contents** for critical features
- **Report build failures immediately** - don't waste time debugging runtime issues if build failed

---

## üî¥ CRITICAL: React Hooks - useEffect Dependencies

### The Problem
When resetting forms from props, using entire objects in useEffect dependency arrays causes form values to be reset while the user is typing, preventing editing.

### ‚ùå WRONG - Causes Form Reset Bugs
```typescript
// ‚ùå BAD - Resets form on every object reference change
React.useEffect(() => {
  reset({ name: tenant.name, email: tenant.email });
}, [tenant, reset]); // ‚ùå This causes typing to be overwritten
```

### ‚úÖ CORRECT - Only Reset When Entity Changes
```typescript
// ‚úÖ GOOD - Only resets when switching to different tenant
React.useEffect(() => {
  reset({ name: tenant.name, email: tenant.email });
}, [tenant?.id, reset]); // ‚úÖ Only resets when ID changes
```

### Pattern to Follow:
- **When resetting forms from props**: Use `[entity?.id, reset]` NOT `[entity, reset]`
- **When reacting to property changes**: Use `[entity.property, reset]`
- **When reacting to all changes**: Use `[entity, reset]` (rare, usually wrong)

### ‚ö†Ô∏è Special Case: Calling Functions from Hook Objects

**When a hook returns an object with functions** (e.g., `useSuggestionJob` returns `{ createJob, restoreJobs, ... }`), do NOT include the object in `useEffect` dependencies. Use a ref pattern instead:

```typescript
// ‚ùå WRONG - Object reference changes on every render, causing unnecessary re-runs
const suggestionJob = useSuggestionJob({ /* ... */ });
React.useEffect(() => {
  if (open && repository?.id) {
    suggestionJob.restoreJobs();
  }
}, [open, repository?.id, suggestionJob]); // ‚ùå Causes flickering
```

```typescript
// ‚úÖ CORRECT - Use ref to access function without triggering re-runs
const suggestionJob = useSuggestionJob({ /* ... */ });
const restoreJobsRef = React.useRef<(() => Promise<void>) | null>(null);
restoreJobsRef.current = suggestionJob.restoreJobs; // Update ref on each render

React.useEffect(() => {
  if (open && repository?.id && restoreJobsRef.current) {
    restoreJobsRef.current(); // Use ref, not object
  }
}, [open, repository?.id]); // ‚úÖ Only depends on primitives
```

**Key Principle**: useEffect dependencies should only contain:
- Primitive values (strings, numbers, booleans)
- Stable references (refs, memoized callbacks)
- Entity IDs (not entire objects)

**Never include**:
- Object references from hooks
- Objects that change on every render
- Functions that aren't memoized

### Examples in Codebase:
- ‚úÖ Correct: `frontend/src/pages/tenants/components/TenantSettingsTab.tsx` (line 93)
- ‚úÖ Correct: `frontend/src/pages/tenants/components/TenantDetailsTab.tsx` (line 68)
- ‚úÖ Correct: `frontend/src/modules/ropa/components/RepositoryFormDialog.tsx` (line 576) - ref pattern for restoreJobs

### Checklist for Forms:
- [ ] Use `entity?.id` in dependency array (not `entity`)
- [ ] Add comment: `// Only reset when entity ID changes, not when object reference changes`
- [ ] Test typing in fields - should not reset while typing
- [ ] Verify form resets when switching to different entity
- [ ] If calling functions from hook objects, use ref pattern (not object in deps)

**Reference**: 
- See `frontend/REACT_HOOKS_GUIDELINES.md` for detailed documentation
- `COMMON_MISTAKES.md` - Mistake 14: useEffect with Object References in Dependencies
- `ROPA_AI_SUGGESTIONS.md` - "useEffect Dependency Fix (2026-01-13)" section

---

## üî¥ CRITICAL: React State Management with Async Updates

### Problem: Direct Function Calls in JSX Don't Trigger Re-renders

When state updates asynchronously (e.g., via polling), calling state accessor functions directly in JSX may not trigger re-renders reliably.

**‚ùå WRONG**:
```typescript
// In form dialog JSX
<FormFieldWithSuggestion
  jobStatus={suggestionJob.getJobStatus('name')}  // ‚ùå May not trigger re-render
/>

// In hook
const getJobStatus = React.useCallback(
  (fieldName: string) => {
    return jobStatuses.get(fieldName) || null;
  },
  [jobStatuses]
);
```

**‚úÖ CORRECT - Use Version Counter Pattern**:
```typescript
// In hook - add version counter
const [jobStatusesVersion, setJobStatusesVersion] = React.useState(0);

// Increment on every state update
setJobStatuses((prev) => {
  const next = new Map(prev);
  next.set(fieldName, status);
  return next;
});
setJobStatusesVersion(prev => prev + 1); // ‚úÖ Increment version

// Return version in hook
return {
  getJobStatus,
  jobStatusesVersion, // ‚úÖ Expose version for dependencies
};

// In form dialog - use useMemo
const nameJobStatus = React.useMemo(
  () => suggestionJob.getJobStatus('name'),
  [suggestionJob, suggestionJob.jobStatusesVersion] // ‚úÖ React tracks version changes
);

// In JSX
<FormFieldWithSuggestion
  jobStatus={nameJobStatus}  // ‚úÖ Memoized value triggers re-renders
/>
```

### Key Principles:

1. **Always use `useMemo` for derived state from async updates**: When state updates asynchronously (polling, websockets, etc.), use version counters or similar mechanisms to ensure React tracks changes properly.

2. **Consistency is critical**: All methods that access the same state should apply the same filters/checks (e.g., `clearedFieldsRef`).

3. **Memoize components that receive frequently changing props**: Use `React.memo` with custom comparison to prevent unnecessary re-renders.

4. **Use refs for immediate checks in async operations**: Refs provide current values without triggering re-renders, essential for race condition protection.

5. **Clean up state aggressively**: When operations complete (Accept All, Decline All), clear all related state to prevent blocking future operations.

6. **Avoid stale closures in useCallback**: When a callback needs current state but shouldn't re-create when state changes, use a ref that's updated on every state change. Don't add state to dependency array if using a ref.

### React Closure Pattern for useCallback:

**Problem**: `useCallback` closures capture state at creation time. If state isn't in the dependency array, the callback always sees the initial value.

**Solution**: Use a ref to track current state value:

```typescript
// Add ref to track current state
const stateRef = React.useRef<StateType>(initialValue);

// Update ref whenever state changes
setState((prev) => {
  const next = computeNext(prev);
  stateRef.current = next; // ‚úÖ Update ref
  return next;
});

// Use ref in callback (no state in deps)
const callback = React.useCallback(() => {
  const currentValue = stateRef.current; // ‚úÖ Always current
  // Use currentValue...
}, [otherDeps]); // ‚úÖ No state in deps - we use ref instead
```

**When to Use This Pattern**:
- Callback needs current state value but shouldn't re-create when state changes
- Async operations (polling, restoration) that need to check current state
- Race condition protection in async operations

**Reference**: 
- `COMMON_MISTAKES.md` - Mistake 8: Direct Function Calls in JSX with Async State Updates
- `ROPA_AI_SUGGESTIONS.md` - "State Management & Performance Optimizations"
- `frontend/src/modules/ropa/hooks/useSuggestionJob.ts` - Example implementation

---

## üî¥ CRITICAL: Layout Consistency

### PageLayout Rules:
1. **ALL pages MUST use PageLayout** (not Container directly)
2. **maxWidth="md"** for all main pages (960px)
3. **maxWidth="xs"** ONLY for auth pages (Login, Register)
4. **NEVER use maxWidth="lg"** in page files

### Pattern:
```typescript
// ‚úÖ CORRECT
<PageLayout maxWidth="md">
  {/* content */}
</PageLayout>

// ‚ùå WRONG
<Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
  {/* content */}
</Container>
```

### Checklist for New Pages:
- [ ] Uses `PageLayout` component (not `Container`)
- [ ] Uses `maxWidth="md"` for main pages (or `maxWidth="xs"` for auth)
- [ ] No nested `maxWidth` or `width` constraints in Paper/Card
- [ ] Paper components use `p: 4` padding

**Reference**: See `frontend/LAYOUT_GUIDELINES.md` for complete layout standards.

---

## üî¥ CRITICAL: Notification System

### Always Use Centralized Notifications

**‚ùå WRONG** - Creating local notification state:
```typescript
const [error, setError] = React.useState<string | null>(null);
const [success, setSuccess] = React.useState<string | null>(null);

return (
  <Box>
    {error && <Alert severity="error">{error}</Alert>}
    {success && <Alert severity="success">{success}</Alert>}
  </Box>
);
```

**‚úÖ CORRECT** - Using centralized notification system:
```typescript
import { useNotification } from '../../../contexts';

export default function MyComponent() {
  const { showSuccess, showError } = useNotification();

  const handleSave = async (data: FormData) => {
    try {
      await updateResource(id, data);
      showSuccess('Resource updated successfully!');
    } catch (err: any) {
      showError(err?.message || 'Failed to update resource');
    }
  };

  return <Box>{/* No Alert components needed */}</Box>;
}
```

### Pattern to Follow:
- **Import**: `import { useNotification } from '../../../contexts';`
- **Use hook**: `const { showSuccess, showError, showWarning, showInfo } = useNotification();`
- **Call methods**: `showSuccess('Message')`, `showError('Message')`, etc.
- **No local state**: Never create `error`/`success` state with Alert components

### When to Use Notifications:
- ‚úÖ Success messages after save/create/update/delete operations
- ‚úÖ Error messages for API failures
- ‚úÖ Warning messages for non-critical issues
- ‚úÖ Info messages for processing states

### When NOT to Use Notifications:
- ‚ùå Form validation errors (use inline Alert components)
- ‚ùå Critical system errors (use inline Alert for persistence)
- ‚ùå Pages that redirect immediately on success

### Examples in Codebase:
- ‚úÖ `frontend/src/pages/tenants/components/TenantSettingsTab.tsx`
- ‚úÖ `frontend/src/pages/tenants/components/TenantDetailsTab.tsx`
- ‚úÖ `frontend/src/pages/tenants/components/TenantMembersTab.tsx`
- ‚úÖ `frontend/src/components/booking/BookingForm.tsx`

**Reference**: See `frontend/COMPONENT_PATTERNS.md` - Notification Pattern

---

## üî¥ CRITICAL: Background Data Refresh (Skip Loading State)

### The Problem
When refreshing data after form submission or delete operations, setting `isLoading(true)` causes the entire page to be replaced with a loading spinner, making it look like a full page reload.

### ‚úÖ CORRECT Pattern

```typescript
// ‚úÖ Add skipLoading parameter
const fetchData = React.useCallback(async (skipLoading = false): Promise<Item[]> => {
  try {
    // ‚úÖ Only set loading state for initial loads
    if (!skipLoading) {
      setIsLoading(true);
    }
    const data = await apiGetItems();
    setItems(data);
    return data;
  } finally {
    // ‚úÖ Only clear loading state if we set it
    if (!skipLoading) {
      setIsLoading(false);
    }
  }
}, []);

// ‚úÖ Initial load - shows spinner
React.useEffect(() => {
  fetchData(); // No parameter = shows loading spinner
}, [fetchData]);

// ‚úÖ Background refresh - no spinner
const handleFormSuccess = async () => {
  await fetchData(true); // skipLoading=true = no full-page spinner
};
```

### ‚ùå INCORRECT Pattern

```typescript
// ‚ùå WRONG: Always sets isLoading, causing full-page spinner
const fetchData = async () => {
  setIsLoading(true); // ‚ùå Always shows full-page spinner
  const data = await apiGetItems();
  setItems(data);
  setIsLoading(false);
};
```

### Key Rules

1. **Add `skipLoading` parameter** - Default to `false` for backward compatibility
2. **Conditional loading state** - Only set `isLoading(true)` when `skipLoading` is `false`
3. **Initial load** - Call `fetchData()` without parameter
4. **Background refresh** - Call `fetchData(true)` after form submission/delete

### Examples in Codebase
- ‚úÖ `frontend/src/modules/ropa/pages/ROPAPage.tsx` - `fetchROPAData(skipLoading)`

**Reference**: See `frontend/COMPONENT_PATTERNS.md` - Background Data Refresh Pattern

---

## üî¥ CRITICAL: Loading Overlay for Details Panel Refresh

### The Problem
When data refreshes in the background (after form submission), the details panel shows stale data for 1-3 seconds. Users don't know if the update succeeded.

### ‚úÖ CORRECT Pattern

```typescript
// Details Panel Component
export default function DetailsPanel({ data, isRefreshing = false }: Props) {
  return (
    <Card sx={{ position: 'relative' }}>
      {/* ‚úÖ Loading Overlay */}
      {isRefreshing && (
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(255, 255, 255, 0.7)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1,
          }}
        >
          <CircularProgress size={40} />
        </Box>
      )}
      <CardContent sx={{ opacity: isRefreshing ? 0.5 : 1, transition: 'opacity 0.2s' }}>
        {/* Content */}
      </CardContent>
    </Card>
  );
}

// Parent Component
const handleFormSuccess = async () => {
  setIsRefreshing(true); // ‚úÖ Set before refresh
  try {
    await fetchData(true);
    // Update selected item
  } finally {
    setIsRefreshing(false); // ‚úÖ Always clear, even on error
  }
};
```

### Key Rules

1. **Add `isRefreshing` prop** - Optional boolean, defaults to `false`
2. **Use absolute positioning** - Overlay covers entire panel
3. **Semi-transparent background** - `rgba(255, 255, 255, 0.7)`
4. **Dim content** - Set opacity to 0.5 during refresh
5. **Always clear state** - Use `try/finally` to ensure state is cleared

### Examples in Codebase
- ‚úÖ `frontend/src/modules/ropa/components/ROPADetailsPanel.tsx`
- ‚úÖ `frontend/src/modules/ropa/pages/ROPAPage.tsx`

**Reference**: See `frontend/COMPONENT_PATTERNS.md` - Loading Overlay Pattern

---

## üî¥ CRITICAL: Model Decoupling - Core Models Must Not Depend on Modules

### The Problem
Core models (User, Tenant) should NEVER have relationships to module-specific models (Appointment, AISuggestionJob). This creates tight coupling and prevents true module independence.

### ‚ùå WRONG - Creates Tight Coupling

```python
# ‚ùå WRONG: User model depends on booker module
class User(Base):
    appointments = relationship(
        "app.modules.booker.models.appointment.Appointment",
        back_populates="user"
    )

# ‚ùå WRONG: User/Tenant depend on ROPA module
class AISuggestionJob(Base):
    user = relationship("User", backref="ai_suggestion_jobs")  # ‚ùå Creates implicit relationship on User
    tenant = relationship("Tenant", backref="ai_suggestion_jobs")  # ‚ùå Creates implicit relationship on Tenant
```

### ‚úÖ CORRECT - One-Way Relationships Only

```python
# ‚úÖ CORRECT: Module models can reference core models (one-way)
class Appointment(Base):
    user_id = Column(UUID, ForeignKey("users.id"))
    user = relationship("User")  # ‚úÖ One-way, no back_populates

class AISuggestionJob(Base):
    user_id = Column(UUID, ForeignKey("users.id"))
    tenant_id = Column(UUID, ForeignKey("tenants.id"))
    user = relationship("User")  # ‚úÖ One-way, no backref
    tenant = relationship("Tenant")  # ‚úÖ One-way, no backref
```

### Pattern to Follow:

1. **Core models (User, Tenant)**: NO relationships to module models
2. **Module models**: Can have one-way relationships to core models
3. **Query module data**: Use service methods, not relationships
   ```python
   # ‚úÖ CORRECT: Query via service
   appointments = AppointmentService.get_by_user(db, user_id=user.id)
   
   # ‚ùå WRONG: Don't use relationship
   appointments = user.appointments  # ‚ùå Not available
   ```

### Why This Matters:

- **Module Independence**: Modules can be disabled/removed without breaking core models
- **SQLAlchemy Initialization**: Core models don't require module imports
- **Celery Workers**: Don't need to import module models for core model usage
- **Scalability**: Adding new modules doesn't clutter core models

### Examples in Codebase:
- ‚úÖ `backend/app/models/user.py` - No module relationships
- ‚úÖ `backend/app/modules/booker/models/appointment.py` - One-way relationship to User
- ‚úÖ `backend/app/modules/ropa/models/ai_suggestion_job.py` - One-way relationships

**Reference**: See `ARCHITECTURE.md` - Model Decoupling Pattern

---

## üî¥ CRITICAL: FastAPI Route Ordering

### The Problem
FastAPI matches routes in registration order. More specific routes (literal paths) MUST come before parameterized routes (`{param}`) to avoid matching conflicts.

### ‚ùå WRONG - Route Order Causes 422 Errors

```python
# ‚ùå WRONG: Parameterized route comes first
@router.get("/suggest-field/{job_id}")  # ‚ùå Matches "/suggest-field/jobs" first!
def get_job(...):
    pass

@router.get("/suggest-field/jobs")  # ‚ùå Never reached, "jobs" parsed as UUID
def list_jobs(...):
    pass
```

### ‚úÖ CORRECT - Specific Routes First

```python
# ‚úÖ CORRECT: Literal path comes first
@router.get("/suggest-field/jobs")  # ‚úÖ Matches literal "jobs" first
def list_jobs(...):
    pass

@router.get("/suggest-field/job/{job_id}")  # ‚úÖ Different path pattern, no conflict
def get_job(...):
    pass
```

### Alternative: Use Different Path Patterns

```python
# ‚úÖ ALTERNATIVE: Use different path segments
@router.get("/suggest-field/jobs")  # List endpoint
def list_jobs(...):
    pass

@router.get("/suggest-field/job/{job_id}")  # Single job (note: /job/ not /{job_id})
def get_job(...):
    pass
```

### Pattern to Follow:

1. **Literal paths first**: `/items/list` before `/items/{id}`
2. **Or use different segments**: `/items/list` and `/items/item/{id}`
3. **Test route order**: Check registration order with `router.routes`
4. **Restart backend**: Route changes require backend restart

### Examples in Codebase:
- ‚úÖ `backend/app/modules/ropa/routers.py` - `/jobs` before `/job/{job_id}`

---

## üî¥ CRITICAL: AI Suggestion Feature Patterns

### Frontend Pattern: FormFieldWithSuggestion

```typescript
// ‚úÖ CORRECT: Wrap form field with suggestion UI
<FormFieldWithSuggestion
  name="description"
  control={control}
  label="Description"
  fieldType="textarea"
  jobStatus={suggestionJob.getJobStatus('description')}
  isSuggesting={
    (() => {
      const status = suggestionJob.getJobStatus('description');
      return status?.status === 'pending' || status?.status === 'processing';
    })()
  }
  onSuggest={async () => {
    try {
      const formData = watch();
      await suggestionJob.createJob(
        'description',
        'text',
        'Description',
        formData.description || '',
        formData
      );
    } catch (err) {
      // Error already shown by hook
    }
  }}
  onAccept={(suggestion) => {
    setValue('description', suggestion, { shouldValidate: true });
  }}
  onDismiss={() => {
    suggestionJob.clearJobStatus('description');
  }}
>
  <FormTextField
    name="description"
    control={control}
    label="Description"
    multiline
    rows={3}
  />
</FormFieldWithSuggestion>
```

### Hook Pattern: useSuggestionJob

```typescript
// ‚úÖ CORRECT: Initialize hook with repository context
const suggestionJob = useSuggestionJob({
  tenantId,
  repositoryId: repository?.id || null,
  enabled: open && !!repository?.id, // Only enable when dialog is open
});

// ‚úÖ CORRECT: Get job status for field
const jobStatus = suggestionJob.getJobStatus('fieldName');

// ‚úÖ CORRECT: Create job
await suggestionJob.createJob(
  'fieldName',
  'text', // or 'select', 'textarea', etc.
  'Field Label',
  currentValue || '',
  formData
);

// ‚úÖ CORRECT: Clear job status
suggestionJob.clearJobStatus('fieldName');
```

### Job Restoration Pattern

The `restoreJobs` function should:
1. Fetch ALL jobs (not just active ones)
2. Group by field_name
3. Get most recent job per field (any status)
4. Restore completed jobs to show results
5. Start polling for active jobs

**CRITICAL**: When calling `restoreJobs` from `useEffect`, use a ref pattern to avoid unnecessary re-triggers:

```typescript
// ‚úÖ CORRECT Pattern for restoreJobs in useEffect
const suggestionJob = useSuggestionJob({ /* ... */ });
const restoreJobsRef = React.useRef<(() => Promise<void>) | null>(null);
restoreJobsRef.current = suggestionJob.restoreJobs;

React.useEffect(() => {
  if (open && entity?.id && restoreJobsRef.current) {
    const timer = setTimeout(() => {
      restoreJobsRef.current?.();
    }, 100);
    return () => clearTimeout(timer);
  }
}, [open, entity?.id]); // ‚úÖ Only depends on open and entity ID
```

**Why**: The `suggestionJob` object gets a new reference on every render, which would cause `useEffect` to re-run unnecessarily, leading to flickering when clicking "Suggest" twice.

**Important**: The `setTimeout` delay (100ms) is intentional to ensure the hook is ready. Do NOT remove it or use `flushSync` as a workaround - these are anti-patterns.

### Backend Pattern: Celery Tasks

```python
# ‚úÖ CORRECT: Import core models, not module models
from app.models import User, Tenant, TenantUser  # ‚úÖ Core models only

# ‚ùå WRONG: Don't import module models unless needed
# from app.modules.booker.models.appointment import Appointment  # ‚ùå Not needed

@celery_app.task
def process_suggestion_job(self, job_id: str):
    # Task implementation
    pass
```

### Key Rules:

1. **Job persistence**: Jobs stored in database, survive logout/login
2. **Polling**: Frontend polls every 2 seconds for active jobs
3. **Restoration**: Most recent job per field restored on form open
4. **Status tracking**: Track pending, processing, completed, failed
5. **Cost tracking**: OpenAI costs stored in database

### Examples in Codebase:
- ‚úÖ `frontend/src/modules/ropa/hooks/useSuggestionJob.ts`
- ‚úÖ `frontend/src/modules/ropa/components/FormFieldWithSuggestion.tsx`
- ‚úÖ `backend/app/modules/ropa/tasks.py`
- ‚úÖ `backend/app/modules/ropa/models/ai_suggestion_job.py`

---

## Project-Specific Notes:

- **Frontend**: React + TypeScript + Vite
- **Backend**: FastAPI + Python
- **Build tool**: Docker Compose
- **Frontend build output**: `frontend/dist/`
- **Nginx serves from**: `/usr/share/nginx/html` (mapped from `frontend/dist`)
- **Deployment**: VPS at `prooflane.xyz` (NOT localhost)
  - ‚ö†Ô∏è **CRITICAL**: The app runs on a VPS, not localhost
  - Debug instrumentation using `localhost` endpoints will fail due to CORS
  - Use browser console logging or proper remote logging endpoints for debugging
  - Never use `fetch('http://localhost:...')` in production code - it will cause CORS errors

---

## Quick Reference Commands:

```bash
# Full build verification
./scripts/verify-build.sh

# Quick frontend build check
cd frontend && npm run build

# Check Docker build logs
docker compose logs frontend-build --tail 50

# Verify code in bundle
grep -r "searchTerm" frontend/dist/assets/*.js

# Rebuild and restart
docker compose build frontend-build && docker compose up -d nginx
```

---

## üîÑ Rebuild Workflow After Code Changes

### Quick Decision Tree

**Choose the right rebuild command based on what changed:**

```
Code Changes?
‚îú‚îÄ‚îÄ Frontend only (React/TypeScript/UI)
‚îÇ   ‚Üí ./scripts/build-frontend.sh (~30-60s)
‚îÇ   ‚Üí docker compose restart nginx
‚îÇ
‚îú‚îÄ‚îÄ Backend only (Python code, no new packages)
‚îÇ   ‚Üí docker compose restart backend (~10s)
‚îÇ
‚îú‚îÄ‚îÄ New dependency added (requirements.txt, package.json)
‚îÇ   ‚Üí ./rebuild.sh (~2-3min)
‚îÇ
‚îú‚îÄ‚îÄ Dockerfile or docker-compose.yml changed
‚îÇ   ‚Üí ./rebuild.sh (~2-3min)
‚îÇ
‚îî‚îÄ‚îÄ Just verify build succeeded
    ‚Üí ./scripts/verify-build.sh (~10-20s)
```

### Detailed Scenarios

#### Scenario 1: Frontend Code Changes Only (Most Common in Cursor AI)

**When to use:**
- React component changes
- TypeScript code changes
- UI/styling changes
- Frontend service/api changes

**Command:**
```bash
./scripts/build-frontend.sh
docker compose restart nginx
```

**What it does:**
- ‚úÖ Increments build number automatically
- ‚úÖ Updates `build-info.json` files
- ‚úÖ Builds frontend using Docker Compose (uses volume mount, fast)
- ‚úÖ Syncs build number to `dist/` directory
- ‚úÖ Restarts nginx to serve new build

**Time:** ~30-60 seconds  
**Why fast:** Uses volume mount, no Docker image rebuild needed

---

#### Scenario 2: Backend Code Changes Only (No New Dependencies)

**When to use:**
- Python code changes in `backend/app/`
- Router/service/model changes
- Configuration changes
- **No new packages in `requirements.txt`**

**Command:**
```bash
docker compose restart backend
```

**What it does:**
- ‚úÖ Restarts backend container with new code
- ‚úÖ Code is already mounted via volume (if using dev setup)
- ‚úÖ Or uses existing built image

**Time:** ~10 seconds  
**Why fast:** No rebuild needed, just restart

**Note:** If code changes aren't reflected, you may need:
```bash
docker compose build backend
docker compose up -d --force-recreate backend
```

---

#### Scenario 3: New Dependency Added

**When to use:**
- Added package to `backend/requirements.txt` (e.g., slowapi)
- Added package to `frontend/package.json`
- Changed Dockerfile
- Changed `docker-compose.yml` service configuration

**Command:**
```bash
./rebuild.sh
```

**What it does:**
- ‚úÖ Stops all services
- ‚úÖ Rebuilds backend with `--no-cache` (installs all dependencies)
- ‚úÖ Rebuilds frontend with `--no-cache`
- ‚úÖ Starts services
- ‚úÖ Runs database migrations (single initial migration creates all 15 tables)
- ‚úÖ Builds frontend assets
- ‚úÖ Restarts nginx

**Time:** ~2-3 minutes  
**Why slow:** Full rebuild with `--no-cache` ensures clean build

---

#### Scenario 4: Verify Build Succeeded

**When to use:**
- After any code changes
- To check for build errors
- To validate bundle output
- Before deploying

**Command:**
```bash
./scripts/verify-build.sh
```

**What it does:**
- ‚úÖ Checks TypeScript compilation
- ‚úÖ Verifies build output exists (`dist/index.html`, `dist/assets/`)
- ‚úÖ Checks bundle size (warns if suspiciously small)
- ‚úÖ Optional: Search for specific code in bundle
- ‚úÖ Increments build number on success

**Time:** ~10-20 seconds  
**Note:** Runs build locally (not in Docker) for faster verification

---

### Rebuild Scripts Reference

| Script | Purpose | Time | When to Use |
|--------|---------|------|-------------|
| `./scripts/build-frontend.sh` | Frontend-only rebuild | ~30-60s | Frontend code changes |
| `docker compose restart backend` | Backend restart | ~10s | Backend code (no deps) |
| `./rebuild.sh` | Complete rebuild | ~2-3min | New dependencies, Docker changes |
| `./scripts/verify-build.sh` | Verify build | ~10-20s | Check build success |

### Best Practices

1. **After AI makes code changes:**
   - Frontend changes ‚Üí `./scripts/build-frontend.sh`
   - Backend changes ‚Üí `docker compose restart backend`
   - New dependency ‚Üí `./rebuild.sh`

2. **Always verify:**
   - Check `docker compose ps` after rebuild
   - Check logs: `docker compose logs backend | tail -20`
   - Verify build: `./scripts/verify-build.sh`

3. **Time-saving tips:**
   - Use `build-frontend.sh` for most frontend changes (fastest)
   - Use `docker compose restart` for backend code-only changes
   - Only use `rebuild.sh` when dependencies or Docker configs change

4. **Troubleshooting:**
   - If changes not reflected ‚Üí Check if rebuild was needed
   - If build fails ‚Üí Check logs: `docker compose logs frontend-build`
   - If backend won't start ‚Üí Check: `docker compose logs backend`

---


